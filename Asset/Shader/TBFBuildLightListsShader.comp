#version 450
#extension GL_GOOGLE_include_directive: enable
#extension GL_EXT_shader_atomic_float2: enable

#include "Object.glsl"
#include "Camera.glsl"
#include "Light.glsl"
#include "Collision.glsl"

#define MAX_LIGHT_COUNT 1024
#define MAX_LIGHT_INDEX_LIST_SIZE 64
#define TILE_WIDTH 32
#define LOCAL_GROUP_WIDTH 8
#define LOCAL_GROUP_STEP (LOCAL_GROUP_WIDTH * LOCAL_GROUP_WIDTH)
#define ITERATER_END_1D (TILE_WIDTH / LOCAL_GROUP_WIDTH)
#define ITERATER_END (ITERATER_END_1D * ITERATER_END_1D)

layout (local_size_x = LOCAL_GROUP_WIDTH, local_size_y = LOCAL_GROUP_WIDTH) in;

layout(set = 0, binding = 0) uniform _CameraInfo
{
    CameraInfo info;
} cameraInfo;

layout(set = 1, binding = 0) uniform LightInfos
{
    LightInfo ambientLightInfo;
    LightInfo mainLightInfo;
    int ortherLightCount;
    LightInfo[MAX_LIGHT_COUNT] ortherLightInfos;
} lightInfos;

layout (set = 2, binding = 0) uniform LightBoundingBoxInfos
{
	int size;
	LightBoundingBoxInfo[MAX_LIGHT_COUNT] infos;
}lightBoundingBoxInfos;

struct LightIndexList
{
	int size;
	int[MAX_LIGHT_INDEX_LIST_SIZE] indexes;
};
layout (set = 3, binding = 0) buffer LightIndexLists
{
	LightIndexList[] lists;
}lightIndexLists;

layout (set = 4, binding = 0, r32f) uniform readonly image2D inputDepthImage;

int Iterater = 0;

ivec2 globalGroupOffset = ivec2(gl_WorkGroupID.xy * TILE_WIDTH);
ivec2 localGroupOffset = ivec2(gl_LocalInvocationID.xy);
int threadLocalIndex = int(gl_LocalInvocationID.y * LOCAL_GROUP_WIDTH + gl_LocalInvocationID.x);
#define iterationOffset (ivec2(Iterater % ITERATER_END_1D, Iterater / ITERATER_END_1D) * LOCAL_GROUP_WIDTH)
#define pixelOffset (globalGroupOffset + localGroupOffset + iterationOffset)

#define globalGroupID (ivec2(gl_WorkGroupID.xy))
#define globalGroupSize (ivec2(gl_NumWorkGroups.xy))
#define globalGroup1DID (globalGroupID.y * globalGroupSize.x + globalGroupID.x)

#define depthImageSize (imageSize(inputDepthImage))

shared float minNdcDepth;
shared float maxNdcDepth;
shared vec4[6] frustumPlanes;
shared int lightIndexListSize;
void main()
{	
	///Init shared
	if(localGroupOffset == ivec2(0, 0))
	{
		minNdcDepth = 1;
		maxNdcDepth = 0;

		lightIndexListSize = 0;
	}
	barrier();

	///Find max min depth
	for(Iterater = 0; Iterater < ITERATER_END; Iterater++)
	{
		vec2 po = pixelOffset;
		if(po.x >= depthImageSize.x || po.y >= depthImageSize.y) continue;
		float pixelNdcDepth = imageLoad(inputDepthImage, ivec2(po)).r;
		atomicMax(maxNdcDepth, pixelNdcDepth);
		atomicMin(minNdcDepth, pixelNdcDepth);
	}
	barrier();

	///Build ggo bounding box
	if(localGroupOffset == ivec2(0, 0))
	{
		int boundingBoxPixelWidth = depthImageSize.x - globalGroupOffset.x >= TILE_WIDTH ? TILE_WIDTH : depthImageSize.x % TILE_WIDTH;
		int boundingBoxPixelHeight = depthImageSize.y - globalGroupOffset.y >= TILE_WIDTH ? TILE_WIDTH : depthImageSize.y % TILE_WIDTH;
	
		vec2[4] NSPositions;
		NSPositions[0] = PositionS2N(vec2(globalGroupOffset) / depthImageSize);
		NSPositions[1] = PositionS2N(vec2(globalGroupOffset + ivec2(0, boundingBoxPixelHeight)) / depthImageSize);
		NSPositions[2] = PositionS2N(vec2(globalGroupOffset + ivec2(boundingBoxPixelWidth, boundingBoxPixelHeight)) / depthImageSize);
		NSPositions[3] = PositionS2N(vec2(globalGroupOffset + ivec2(boundingBoxPixelWidth, 0)) / depthImageSize);

		vec3[4] nearVSPositions;
		nearVSPositions[0] = PositionN2V(vec3(NSPositions[0], minNdcDepth), cameraInfo.info);
		nearVSPositions[1] = PositionN2V(vec3(NSPositions[1], minNdcDepth), cameraInfo.info);
		nearVSPositions[2] = PositionN2V(vec3(NSPositions[2], minNdcDepth), cameraInfo.info);
		nearVSPositions[3] = PositionN2V(vec3(NSPositions[3], minNdcDepth), cameraInfo.info);
		
		vec3[4] farVSPositions;
		farVSPositions[0] = PositionN2V(vec3(NSPositions[0], maxNdcDepth), cameraInfo.info);
		farVSPositions[1] = PositionN2V(vec3(NSPositions[1], maxNdcDepth), cameraInfo.info);
		farVSPositions[2] = PositionN2V(vec3(NSPositions[2], maxNdcDepth), cameraInfo.info);
		farVSPositions[3] = PositionN2V(vec3(NSPositions[3], maxNdcDepth), cameraInfo.info);

		///left
		frustumPlanes[0] = BuildPlane(nearVSPositions[0], nearVSPositions[1], farVSPositions[1]);
		///right
		frustumPlanes[1] = BuildPlane(nearVSPositions[3], farVSPositions[3], farVSPositions[2]);
		///bottom
		frustumPlanes[2] = BuildPlane(nearVSPositions[1], nearVSPositions[2], farVSPositions[2]);
		///top
		frustumPlanes[3] = BuildPlane(nearVSPositions[0], farVSPositions[0], farVSPositions[3]);
		///near
		frustumPlanes[4] = BuildPlane(nearVSPositions[0], nearVSPositions[3], nearVSPositions[2]);
		///far
		frustumPlanes[5] = BuildPlane(farVSPositions[3], farVSPositions[0], farVSPositions[1]);
	}
	barrier();

	///Intersection test
	for(int i = threadLocalIndex; i < lightBoundingBoxInfos.size; i += LOCAL_GROUP_STEP)
	{
		bool intersected = ObbPlaneMatrixIntersection(lightBoundingBoxInfos.infos[i].vertexes, frustumPlanes, cameraInfo.info.view);
		if(intersected)
		{
			int storeIndex = atomicAdd(lightIndexListSize, 1);
			if(storeIndex >= MAX_LIGHT_INDEX_LIST_SIZE) break;
			lightIndexLists.lists[globalGroup1DID].indexes[storeIndex] = i;
		}
	}
	barrier();

	///Set size
	if(localGroupOffset == ivec2(0, 0))
	{
		lightIndexLists.lists[globalGroup1DID].size = lightIndexListSize;
	}
}
