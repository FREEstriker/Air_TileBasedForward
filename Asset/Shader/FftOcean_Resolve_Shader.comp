#version 450
#extension GL_GOOGLE_include_directive: enable

#define LOCAL_GROUP_WIDTH 16
layout (local_size_x = LOCAL_GROUP_WIDTH, local_size_y = LOCAL_GROUP_WIDTH) in;

#define PI (3.141592653589793)
#define G (9.81)

layout(push_constant) uniform ResolveConstantInfo
{
    ivec2 imageSize;
	ivec2 NM;
	int heightImageIndex;
	int xImageIndex;
	int yImageIndex;
	// int xSlopeImageIndex;
	// int ySlopeImageIndex;
	vec2 L;
	float bubblesLambda;
	float bubblesThreshold;
	float bubblesScale;
} constantInfo;

layout (set = 0, binding = 0, rg32f) uniform readonly image2DArray imageArray;
layout (set = 1, binding = 0, rgba32f) uniform image2D displacementImage;
layout (set = 2, binding = 0, rgba32f) uniform image2D normalImage;

void main()
{	
	// thread/saple Y = world Z
	const ivec2 threadPosition = ivec2(gl_GlobalInvocationID.xy);

	if(constantInfo.imageSize.x <= threadPosition.x || constantInfo.imageSize.y <= threadPosition.y) return;
	
	const ivec2 pixelPosition = threadPosition;
	const int MN = constantInfo.NM.x * constantInfo.NM.y;

	const float height = length(imageLoad(imageArray, ivec3(pixelPosition, constantInfo.heightImageIndex)).rg) / MN;
	const float x = length(imageLoad(imageArray, ivec3(pixelPosition, constantInfo.xImageIndex)).rg) / MN;
	const float y = length(imageLoad(imageArray, ivec3(pixelPosition, constantInfo.yImageIndex)).rg) / MN;
	imageStore(displacementImage, pixelPosition, vec4(x, height, y, 0));

	memoryBarrierImage();

	// const vec2 uintLength = constantInfo.L / (constantInfo.NM - vec2(1));//两点间单位长度
	const vec2 uintLength = vec2(0);//两点间单位长度
    //获取当前点，周围4个点的uv坐标
    const ivec2 uvX1 = ivec2((pixelPosition.x - 1 + constantInfo.NM.x) % constantInfo.NM.x, pixelPosition.y);
    const ivec2 uvX2 = ivec2((pixelPosition.x + 1 + constantInfo.NM.x) % constantInfo.NM.x, pixelPosition.y);
    const ivec2 uvZ1 = ivec2(pixelPosition.x, (pixelPosition.y - 1 + constantInfo.NM.y) % constantInfo.NM.y);
    const ivec2 uvZ2 = ivec2(pixelPosition.x, (pixelPosition.y + 1 + constantInfo.NM.y) % constantInfo.NM.y);

    //以当前点为中心，获取周围4个点的偏移值
    const vec3 x1D = imageLoad(displacementImage, uvX1).xyz;//在x轴 第一个点的偏移值
    const vec3 x2D = imageLoad(displacementImage, uvX2).xyz;//在x轴 第二个点的偏移值
    const vec3 z1D = imageLoad(displacementImage, uvZ1).xyz;//在z轴 第一个点的偏移值
    const vec3 z2D = imageLoad(displacementImage, uvZ2).xyz;//在z轴 第二个点的偏移值

    //以当前点为原点，构建周围4个点的坐标
    const vec3 x1 = vec3(x1D.x - uintLength.x, x1D.yz);//在x轴 第一个点的坐标
    const vec3 x2 = vec3(x2D.x + uintLength.x, x2D.yz);//在x轴 第二个点的坐标
    const vec3 z1 = vec3(z1D.xy, z1D.z - uintLength.y);//在z轴 第一个点的坐标
    const vec3 z2 = vec3(z2D.xy, z2D.z + uintLength.y);//在z轴 第二个点的坐标

    //计算两个切向量
    const vec3 tangentX = x2 - x1;
    const vec3 tangentZ = z2 - z1;

    //计算法线
    const vec3 normal = normalize(cross(tangentZ, tangentX));

	// const float xSlope = length(imageLoad(imageArray, ivec3(pixelPosition, constantInfo.xSlopeImageIndex)).rg) / MN;
	// const float ySlope = length(imageLoad(imageArray, ivec3(pixelPosition, constantInfo.ySlopeImageIndex)).rg) / MN;
	// const vec3 normal = normalize(vec3(-xSlope, 0.001, -ySlope));

	//计算泡沫
    const vec3 ddx = x2D - x1D;
    const vec3 ddz = z2D - z1D;
    //雅可比行列式
    float jacobian = (1.0f + constantInfo.bubblesLambda * ddx.x) * (1.0f + constantInfo.bubblesLambda * ddz.z) - constantInfo.bubblesLambda * ddx.z * constantInfo.bubblesLambda * ddz.x;

    jacobian = clamp(max(0, constantInfo.bubblesThreshold - clamp(jacobian, 0, 1)) * constantInfo.bubblesScale, 0, 1);

	imageStore(normalImage, pixelPosition, vec4(normal, jacobian));
}